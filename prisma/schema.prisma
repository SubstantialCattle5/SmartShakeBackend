// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id          Int      @id @default(autoincrement())
  phone       String   @unique
  email       String?  @unique
  name        String?
  password    String?  // Optional for OTP-only users
  isVerified  Boolean  @default(false)
  isActive    Boolean  @default(true)
  deleted     Boolean  @default(false)  // Soft delete flag
  role        UserRole @default(USER)  // USER, ADMIN, TECH
  lastLoginAt DateTime?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  otpCodes              OtpCode[]
  blacklistedTokens     BlacklistedToken[]
  drinkVouchers         DrinkVoucher[]
  orders                Order[]
  consumptions          Consumption[]
  paymentMethods        PaymentMethod[]
  transactions          Transaction[]

  @@map("users")
  @@index([role])
  @@index([isActive, role])
  @@index([deleted])
}

model OtpCode {
  id        Int      @id @default(autoincrement())
  phone     String
  code      String
  purpose   OtpPurpose @default(LOGIN)
  expiresAt DateTime
  used      Boolean  @default(false)
  userId    Int?
  user      User?    @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())

  @@map("otp_codes")
  @@index([phone, purpose])
  @@index([code])
}

model BlacklistedToken {
  id        Int      @id @default(autoincrement())
  tokenHash String   @unique  // Hash of the JWT token for security
  userId    Int
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  expiresAt DateTime // When the original token expires
  reason    String?  // Optional reason for blacklisting (logout, security, etc.)
  createdAt DateTime @default(now())

  @@map("blacklisted_tokens")
  @@index([tokenHash])
  @@index([userId])
  @@index([expiresAt])
}

// ========================================
// DRINK VOUCHER SYSTEM
// ========================================

model DrinkVoucher {
  id                Int      @id @default(autoincrement())
  userId            Int
  user              User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Voucher Details
  voucherNumber     String   @unique  // e.g., "VCH-2024-001234"
  totalDrinks       Int      // Total drinks in this voucher (e.g., 20)
  consumedDrinks    Int      @default(0)  // Number of drinks consumed
  // remainingDrinks is computed: totalDrinks - consumedDrinks
  
  // Pricing
  pricePerDrink     Decimal  @db.Decimal(10, 2)  // Price per drink
  totalPrice        Decimal  @db.Decimal(10, 2)  // Total voucher cost
  
  // Voucher Status and Timing
  status            VoucherStatus @default(ACTIVE)
  isActivated       Boolean  @default(false)  // Whether voucher has been first used
  purchaseDate      DateTime @default(now())
  firstUsedAt       DateTime?  // When voucher was first used at a machine
  expiryDate        DateTime?  // Optional expiry date
  
  // Concurrency control
  version           Int      @default(1)  // Optimistic locking version
  
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  // Relations
  consumptions      Consumption[]
  order             Order?   @relation(fields: [orderId], references: [id])
  orderId           Int?

  @@map("drink_vouchers")
  @@index([userId, status])
  @@index([voucherNumber])
  @@index([expiryDate])
  @@index([isActivated, status])
  @@index([version]) // For optimistic locking
}

// ========================================
// CONSUMPTION TRACKING
// ========================================

model Consumption {
  id             Int      @id @default(autoincrement())
  userId         Int
  user           User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  voucherId      Int
  voucher        DrinkVoucher @relation(fields: [voucherId], references: [id], onDelete: Cascade)
  
  // Basic consumption info
  quantity       Int      @default(1)  // Number of drinks consumed (max 10 per transaction)
  consumedAt     DateTime @default(now())
  
  // Machine info (from scanned QR code)
  machineId      String   // Reference to machine ID from scanned QR code
  machineQRCode  String?  // The actual QR code that was scanned
  location       String?  // Machine location info
  drinkType      String?  // Optional: type of drink selected (e.g., "Cola", "Water")
  drinkSlot      String?  // Optional: which slot/product was dispensed
  
  // Integration fields
  externalTransactionId String? @unique // Transaction ID from vending machine backend
  vendingSessionId      String? // Session ID when user scanned QR and started interaction
  status         ConsumptionStatus @default(COMPLETED)
  notes          String?  // Optional notes
  
  // Audit fields for tracking issues
  preConsumptionBalance  Int      // Voucher balance before this consumption
  postConsumptionBalance Int      // Voucher balance after this consumption
  voucherVersion         Int      // Version of voucher when consumption happened
  
  createdAt      DateTime @default(now())
  
  @@map("consumptions")
  @@index([userId, consumedAt])
  @@index([voucherId])
  @@index([machineId, consumedAt]) // For machine analytics
  @@index([externalTransactionId])
  @@index([vendingSessionId])
}

// ========================================
// VENDING MACHINE INTEGRATION
// ========================================

model VendingMachine {
  id          Int      @id @default(autoincrement())
  machineId   String   @unique  // External machine ID
  name        String   // Machine display name
  location    String   // Location description
  address     String?  // Full address
  city        String
  state       String?
  pincode     String?
  
  // Machine status
  isActive    Boolean  @default(true)
  isOnline    Boolean  @default(false)
  lastPing    DateTime? // Last heartbeat from machine
  
  // QR Code for this machine (what users scan)
  qrCode      String   @unique // QR code users scan to start transaction
  qrCodeType  String   @default("MACHINE_ID") // Type of QR code encoding
  
  // Integration
  apiEndpoint String?  // Machine's API endpoint for communication
  apiKey      String?  // Authentication key for machine
  version     String?  // Machine software version
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@map("vending_machines")
  @@index([city])
  @@index([isActive, isOnline])
  @@index([qrCode])
}

// ========================================
// ORDER & PAYMENT MODELS
// ========================================

model Order {
  id              Int      @id @default(autoincrement())
  userId          Int
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  orderNumber     String   @unique  // e.g., "ORD-2024-001"
  
  // Order Details
  orderType       OrderType @default(VOUCHER_PURCHASE)  // VOUCHER_PURCHASE or VOUCHER_TOPUP
  totalDrinks     Int?     // Number of drinks being purchased
  totalAmount     Decimal  @db.Decimal(10, 2)
  
  // Status
  status          OrderStatus @default(PENDING)
  paymentStatus   PaymentStatus @default(PENDING)
  notes           String?
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relations
  drinkVouchers   DrinkVoucher[]
  transactions    Transaction[]

  @@map("orders")
  @@index([userId, status])
  @@index([status, createdAt])
  @@index([paymentStatus])
}

model PaymentMethod {
  id           Int      @id @default(autoincrement())
  userId       Int
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  type         PaymentType
  provider     String   @default("phonepe")  // PhonePe integration
  externalId   String?  // PhonePe payment method ID
  isDefault    Boolean  @default(false)
  lastFour     String?  // Last 4 digits for cards
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  // Relations
  transactions Transaction[]

  @@map("payment_methods")
  @@index([userId, isDefault])
}

model Transaction {
  id                    Int           @id @default(autoincrement())
  userId                Int
  user                  User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  orderId               Int?
  order                 Order?        @relation(fields: [orderId], references: [id])
  paymentMethodId       Int?
  paymentMethod         PaymentMethod? @relation(fields: [paymentMethodId], references: [id])
  
  status                TransactionStatus @default(PENDING)
  type                  TransactionType @default(PAYMENT)
  amount                Decimal       @db.Decimal(10, 2)
  currency              String        @default("INR")
  
  // PhonePe Integration Fields
  phonepeTransactionId  String?       // PhonePe transaction ID
  phonepeOrderId        String?       // PhonePe order ID
  phonepeMerchantId     String?       @unique // Merchant transaction ID (must be unique)
  phonepeResponse       Json?         // Full PhonePe response
  phonepeCallbackData   Json?         // Callback webhook data
  
  failureReason         String?
  processedAt           DateTime?
  createdAt             DateTime      @default(now())
  updatedAt             DateTime      @updatedAt

  @@map("transactions")
  @@index([userId, status])
  @@index([status, processedAt])
  @@index([phonepeTransactionId])
  @@index([phonepeMerchantId])
}

// ========================================
// ENUMS
// ========================================

enum OtpPurpose {
  LOGIN
  REGISTRATION
  PASSWORD_RESET
  PHONE_VERIFICATION
}

enum UserRole {
  USER        // Regular customers
  TECH        // Technical support staff
  ADMIN       // System administrators
}

enum VoucherStatus {
  ACTIVE      // Voucher is active and can be used
  EXPIRED     // Voucher has expired
  EXHAUSTED   // All drinks have been consumed
  SUSPENDED   // Voucher is temporarily suspended
  CANCELLED   // Voucher has been cancelled/refunded
}

enum ConsumptionStatus {
  COMPLETED
  FAILED
  PENDING
  CANCELLED
  REVERSED    // For handling refunds/corrections
}

enum OrderType {
  VOUCHER_PURCHASE  // New voucher purchase
  VOUCHER_TOPUP     // Adding drinks to existing voucher (if supported)
}

enum OrderStatus {
  PENDING
  CONFIRMED
  COMPLETED
  CANCELLED
}

enum PaymentStatus {
  PENDING
  PAID
  FAILED
  REFUNDED
}

enum PaymentType {
  UPI
  CREDIT_CARD
  DEBIT_CARD
  NET_BANKING
  WALLET
}

enum TransactionStatus {
  PENDING
  SUCCESS
  FAILED
  CANCELLED
  REFUNDED
}

enum TransactionType {
  PAYMENT
  REFUND
  ADJUSTMENT
} 